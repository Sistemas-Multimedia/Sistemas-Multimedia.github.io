\input{../definitions}
\title{\SM{} - Study Guide - Milestone 12: IPP... coding in MRVC (Multi Resolution Video Codec)}

\maketitle

\section{Description}

\subsection{The IPP... decorrelation pattern}
It's time to put together all the tools that we have developed for
encoding a sequence of frames. We will call to this set of images, a
Group Of Frames (GOF), and the structure of each GOP will be IPP...,
which means that the first frame of each GOF will be intra-coded
(I-type), and the rest of frames of the GOF will be predicted-coded
(P-type). Notice that in a I-type frame all the coefficients will be
I-type, and in a P-type frame, the different coefficients can be
I-type or P-type.

\subsection{Multiresolution iterations}
In each IPP... iteration, only a sequence of $[H]$ subbands is
decorrelated considering the information provided by the $[L]$
subbands. Therefore, in order to increase the CR, a minimum number of
IPP... iterations should be carried out. The number of iterations
controls the number of SRLs (Spatial Resolution Levels)
$N_{\text{SRL}}$ generated, where
\begin{equation}
  N_{\text{SRL}} = \text{the number of IPP... iterations} + 1.
\end{equation}
The output of an IPP... iteration will be refered as ``an
spatial-layer of code-stream'', or simply as ``a S-layer''.

\subsection{Spatial scalability}
It's easy to see that IPP...-type MRVC sequences are scalable in
Spatial-resolution (S-progression) as long as more MC-layers are
received, and that also Quality (Q-progression) scalability in each
SRL can be achieved for the $[H]$ texture\footnote{The $[L]$ must be
always decoded with the quality that the encoder used for reconstruct
the corresponding SRL.} by simply using a quality-scalable image codec
such as JPEG2000, generating a number $N_{\text{QL}}$ of quality-layers
by each $[H]$ subband. Notice, however, that using this encoding
configuration, the only allowed\footnote{Suposing that the order of
the layers could be modified in the code-stream.} progression is the
SQ-progression, that can be Pythonically-described by
\begin{verbatim}
progression = []
for S_layer in range(N_SRL-1, 0, -1):
  for Q_layer in range(N_QL-1, 0, -1):
    progression.append((S_layer, Q_layer))
\end{verbatim}

For example, if $N_{\text{SRL}}=3$ (2 IPP...-type iterations)
and $N_{\text{QL}}=2$, the progression of layers would be:
\begin{verbatim}
progression = [
  (S_layer=2, Q_layer=1),  <-- The first one to be recived
  (S_layer=2, Q_layer=0),
  (S_layer=1, Q_layer=1),
  (S_layer=1, Q_layer=0),
  (S_layer=0, Q_layer=1),
  (S_layer_0, Q_layer=0) ] <-- The last one
\end{verbatim}
Notice that if the quality-scalable image compressor has been
configured as lossless for the quality-layer 0, this example
would be lossless when all the layers has been received.

\subsection{A block diagram of the codec}
\svg{graphics/codec}{1200}

\section{What you have to do?}

Implement the previous codec, preferiblemente in a Jupyter notebook. 

\section{Timming}

Please, finish this notebook before the next class session.

\section{Deliverables}

None.

\section{Resources}

\bibliography{python}
