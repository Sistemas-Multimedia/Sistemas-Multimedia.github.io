\input{../../definitions}
\title{\SM{} - Study Guide - Milestone 12: IPP... coding in MRVC (Multi Resolution Video Codec)}

\maketitle

\section{Description}

\subsection{The IPP... decorrelation pattern}
It's time to put together all the ``tools'' that we have developed for
encoding a sequence of DWT decompositions (\emph{decomps} in
short). First, the sequence will be splitted into GODs (Group Of
Decomps), and the structure of each GOD will be
IPP...~\cite{le1991mpeg}, which means that the first decomp of each
GOD will be intra-coded (I-type), and the rest of decomps of the GOF
will be predicted-coded (P-type), respect to the previous
one\footnote{A P-type decomp except for the second decomp.}. Notice
that in an I-type decomp all the coefficients (\emph{coeff}s in short)
will I-type coeffs, and in a P-type frame, the different coeffs can be
I-type or P-type.

\subsection{Multiresolution iterations}
In each IPP... iteration, only the high-frequency components of the
sequence of decoms are decorrelated ($[H]$ subbands) considering the
information provided by the low-frequency components ($[L]$ subbands),
which are losslessly\footnote{The $[L]$ information must be always
decoded with the quality that the encoder used for reconstruct the
corresponding SRL.} transmitted between the encoder and the decoder.

In order to increase the compression ratio, a minimum number of
IPP... iterations should be carried out. In fact, the number of
iterations controls the number of SRLs (Spatial Resolution Levels)
$N_{\text{SRL}}$ generated, where
\begin{equation}
  N_{\text{SRL}} = \text{the number of IPP... iterations} + 1.
\end{equation}
The output of an IPP... iteration will be refered as ``a
spatial-layer of code-stream'', or simply as ``a S-layer''.

\subsection{A block diagram of the codec}
\begin{figure}
  \centering
  \svg{graphics/codec}{700}
  \caption{The IPP... MRCV video codec.}
  \label{fig:codec}
\end{figure}

The MRVC IPP... codec has been described in the
Fig.~\ref{fig:codec}. The equations that describe this system are:

\begin{equation}
  (D_k.L, D_k.H) = \text{DWT}(D_k),
  \tag{a}
\end{equation}
where $D_k$ is the $k$-th decomp. of the sequence,

\begin{equation}
  [D_k.L] = \text{DWT}^{-1}(0, D_k.L),
  \tag{b}
\end{equation}

\begin{equation}
  Z^{-1}([D_k.L]) = [D_{k-1}.L],
  \tag{c}
\end{equation}
and by definition, $Z^{-1}([D_{-1}.L]) = 0$.

\begin{equation}
  \overset{k\rightarrow k+1}{V} = \text{ME}([D_k.L], [D_{k-1}.L]),
  \tag{d}
\end{equation}
where ME stands for Motion Estimation, and by definition,
$\overset{-1\rightarrow 0}{V}=0$,

\begin{equation}
  [\hat{D}_k.L] = \text{MCP}(\overset{k\rightarrow k+1}{V}, [D_{k-1}.L]),
  \tag{e}
\end{equation}
where MCP stands for Motion Compensated Prediction,

\begin{equation}
  [E_k.L] = [D_k.L] - [\hat{D}_k.L],
  \tag{f}
\end{equation}

\begin{equation}
  \{[T_k],[M_k]\} = \text{EW-min}([D_k.L], [E_k.L])
  \tag{g}
\end{equation}
where
\begin{equation}
  [T_k]_{i,j}=\text{min}([D_k.L]_{i,j}, [E_k.L]_{i,j}),
\end{equation}
and $[M_k]$ is a binary matrix defined by
\begin{equation}
  [M_k]_{i,j} = \left\{
  \begin{array}{ll}
    0 & \text{if}~[D_k.L]_{i,j} < [E_k.L]_{i,j} \\
    1 & \text{otherwise},
  \end{array}
  \right.
  \label{eq:matrix}
\end{equation}
(notice that $[T_k]$, that contains the element-wise minimum of both
matrices, is discarded)

\begin{equation}
  [D_k.H] = \text{DWT}^{-1}(0, D_k.H),
  \tag{h}
\end{equation}

\begin{equation}
  [E_k.H] = [D_k.H] - [\hat{D}_k.H],
  \tag{i}
\end{equation}
where, notice that
\begin{equation}
  [E_k.H] = \left\{
  \begin{array}{ll}
    {[}D_k.H{]} - [\hat{D}_k.H] & \text{(inter coded coeff.)} \\
    {[}D_k.H{]}                 & \text{(intra codec coeff.)},
  \end{array}
  \right.
\end{equation}
and notice that if $[\hat{D}_k.H]=0$ then $[E_k.H] = [D_k.H]$,

\begin{equation}
  [\tilde{E}_k.H] = \text{Q}([E_K.H]),
  \tag{j}
\end{equation}

\begin{equation}
  [\tilde{E}_k.H] = \text{Q}^{-1}([\tilde{E}_K.H]),
  \tag{k}
\end{equation}

\begin{equation}
  [\tilde{D}_k.H] = [\tilde{E}_k.H] + [\hat{D}_k.H],
  \tag{l}
\end{equation}
and notice that if $[\hat{D}_k.H]=0$ then $[\tilde{D}_k.H] =
[\tilde{E}_k.H]$,

\begin{equation}
  Z^{-1}([\tilde{D}_k.H]) = [D_{k-1}.H],
  \tag{m}
\end{equation}
and by definition, $Z^{-1}([D_{-1}.H]) = 0$,

\begin{equation}
  [\hat{D}_k.H] = \text{MCP}(\overset{k\rightarrow k+1}{V}, [D_{k-1}.H]),
  \tag{n}
\end{equation}

\begin{equation}
  (0, \tilde{E}_k.H) = \text{DWT}([\tilde{E}_k.H]),
  \tag{o}
\end{equation}

\begin{equation}
  \{\hat{D}_k.L, \tilde{E}_k.H\} = \text{E}(\hat{D}_k.L, \tilde{E}_k.H),
  \tag{p}
\end{equation}
where E represents the entropy coding of both data sources, in two
different code-streams,

\begin{equation}
  (\hat{D}_k.L, \tilde{E}_k.H) = \text{E}^{-1}(\{\hat{D}_k.L, \tilde{E}_k.H\}),
  \tag{q}
\end{equation}

and

\begin{equation}
  \tilde{D}_k = \text{DWT}^{-1}(D_k.L, D_k.H).
  \tag{r}
\end{equation}

\subsection{Scalability}
It's easy to see that an IPP...-type MRVC sequence is progressive in
Spatial-resolution (S-progression) as long as more S-layers are
received. Moreover, Quality (Q-progression) scalability in each SRL
can be achieved in the encoding of the $[H]$ texture if a
quality-scalable image codec such as
JPEG2000~\cite{taubman2002jpeg2000} is used, generating a number
$N_{\text{QL}}$ of quality-layers by each $[H]$ subband. Notice,
however, that using this encoding configuration, the only
allowed\footnote{Suposing that the order of the layers could be
modified in the code-stream.} progression is the SQ-progression, that
can be Pythonically-described by
\begin{verbatim}
progression = []
for S_layer in range(N_SRL-1, 0, -1):
  for Q_layer in range(N_QL-1, 0, -1):
    progression.append((S_layer, Q_layer))
\end{verbatim}

For example, if $N_{\text{SRL}}=3$ (2 IPP...-type iterations) and
$N_{\text{QL}}=2$, the progression of layers would be:
\begin{verbatim}
progression = [
  (S_layer=2, Q_layer=1),  <-- The first one to be recived
  (S_layer=2, Q_layer=0),
  (S_layer=1, Q_layer=1),
  (S_layer=1, Q_layer=0),
  (S_layer=0, Q_layer=1),
  (S_layer_0, Q_layer=0) ] <-- The last one
\end{verbatim}

The use of quality scalability boosts the possibilities in real-time
streaming scenarios where the transmission bit-rate can be
variable. However, notice that the use of versions of the decomps at
the decoder side with a smaller quality (and this will depends on the
transmission bit-rate) will generate a drift-error in the
reconstruction of the video because the predictions used at the
encoder and the decoder are not identical. Notice, however, that the
spatial scalability provided by this scheme is free of drift-error.

\section{What you have to do?}

Implement the previous codec, preferiblemente in a (or several)
Jupyter notebook(s). Test it by tracing a RD curve for different
$\Delta$ values for the quantizer (see Eqs. (j) and (k)). Compare it
with the curve generated without using motion compensation.

\section{Timming}

In groups, you will present the results for this milestone during the
examination time.

\section{Deliverables}

The notebook(s) and the presentation.

\section{Resources}

\bibliography{video_compression,JPEG2000}
