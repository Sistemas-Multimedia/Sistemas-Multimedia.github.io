% Emacs, this is -*-latex-*-

\input{../../definitions}
\title{Lossy Compression of Gray-scale Images}

\maketitle
\tableofcontents

\section{Description}
%{{{

Gray-Scale (GS) images only have one (color) channel, at it is usually
represented in color displays using gray color tones (the same amount
if red, green and blue components). In most of the cases, the number
of bits per pixel (the depth of the image) is 8, but it is not rare to
use up to 16 bits/pixel~\cite{burger2016digital}. However, it is quite
difficult to find a color display with more than 256 gray colors.

In this milestone we will see how to
\href{https://vicente-gonzalez-ruiz.github.io/quantization/}{quantize}
the image, and then compression the image with PNG, to create a
\href{https://en.wikipedia.org/wiki/Lossy_compression}{lossy image
  compressor}.

\subsection{Scalar and vector quantization of GS images}
%{{{

The compression ratio of our lossy image compressor can be controled
by means of quantization. At this point we have basically two
alternatives:
\begin{enumerate}
\item \textbf{Scalar Quantization (SQ)}: each pixel is quantized
  without considering the rest.
\item \textbf{Vector Quantization (VQ)}: the pixels are quantized
  block-by-block (2D vectors).
\end{enumerate}
Notice that VQ exploits the spatial correlation, but not SQ. For this
reason, we will use PNG after SQ. In the case of VQ, only the
statistical redundancy remains, that can be exploited with Arithmetic
Coding, for example.

%}}}

\subsection{Bit-rate control}
%{{{

The bit-rate (the number of bits/pixel) obtained after using
quantization + PNG depends on:
\begin{enumerate}
\item The capability of PNG for removing spatial redudancy, aspect
  that we cannot control with accuracy (only some levels of
  compression are usually available and the bit-rates are quite
  similar).
\item The quantization step $\Delta$ used. The higher the $\Delta$,
  the higher the compression ratio, the lower the number of
  bits/pixel, the lower the quality of the reconstructed image.
\end{enumerate}
Variying $\Delta$ we should be able to generate a Rate/Distortion (RD)
curve, where the X-axis represents the bit-rate (in bit/pixe, for
example) and the Y-axis represents the distortion (the
\href{https://en.wikipedia.org/wiki/Root-mean-square_deviation}{Root
  Mean Square Error (RMSE)}, for example).

Normaly, RD curves are convex (see Fig.~\ref{fig:RD_slopes}), which
means that if $\lambda_i$ is the slope of the curve measured at the
$i$-th point of the curve (starting at the lowest bit-rate), it
usually hold that
\begin{equation}
  \lambda_i > \lambda_{i+1}.
  \label{eq:convexity}
\end{equation}
where $\lambda$ quantifies the trade-off between decreasing the
distortion\footnote{For this reason, the slopes are negative.} while
the bit-rate
increases~\cite{vetterli1995wavelets,sayood2017introduction}. However,
Eq.~\ref{eq:convexity} is not always true. This can be seen in the
notebooks \href{}{midtread\_quantization},
\href{midrise\_quantization}, \href{deadzone\_quantization} and
\href{}{companded\_quantization}.

As it can be also seen in the notebook
\href{}{quantizers\_comparison}, the performance of the quantizers is
not the same (usually midrise and midtread, performs better than
deadzone at intermediate bit-rates, but deadzone is the best a low
bit-rates. Deadzone has also another advantage over midread and
midtread: when $\Delta$ is a power of 2 (which corresponds to a
bit-plane encoding), the obtained RD point is near optimal in the RD
space.

%}}}

\subsection{Trellis-Coded Quantization (TCQ)}

TCQ uses a collection of non-overlapped scalar quantizers, and,
depending on the flexibility to chose one of these quantizers to
encode the sample ${\mathbf s}_i$ (after having quantized the sample
${\mathbf s}_{i-1}$) we output a number of bits, for a given sequence
of input samples, that select the optimal order of quantizers that
minimize the distortion. Notice that the input is processed by blocks
of samples, and for this reason, some people refers TCQ as a type of
VQ. Therefore, TCQ inputs a block of samples and outputs a block of
bits (always with the same length). The advantage of TCQ is that the
output bits determine the order in which the quantizers must be used
to minimize the distortion encoding the input block.

The number of output bits depends on the number of quantizers and the
flexibility to select a quantizer\footnote{The higher the flexibility,
the higher the number of bits necessary to indicate the selected
quantizer.} after having used a previous one (that can be the
same). The transitions allowed between quantizers determine the so
called \emph{trellis}-step, that has so many steps as symbols are in
an input block. After building the complete trellis, the Viterbi
algorithm~\cite{} is used for selecting those sequence of quantizers
that minimize the distortion.\footnote{Basically, Viterbi found a way
of finding the most likely sequence of states of a finite-state
machine when the input (that describes the sequence) has been
corrupted by the noise. In our case, we want to find the sequence of
states (quantizers) that minimizes the distortion (quantization
error).}

\subsection*{Example}
Lets suppose the following (scalar and uniform) quantizer~\cite{}:

\begin{verbatim}
-3.5   -2.5   -1.5   -0.5    0.5    1.5    2.5    3.5
--+------+------+------+------+------+------+------+--
 000    001    010    011    100    101    110    111
\end{verbatim}

and that we want to quantize the input: 0.2, 1.6 and 2.3. If we use
directly such quantizer we get:

\begin{verbatim}
Input Output |Error| Code
-------------------------
  0.2    0.5     0.3  011
  1.6    1.5     0.1  101
  2.3    2.5     0.2  110
\end{verbatim}

The total error is (distortion) 0.6 and we need (rate) 9 bits.

Now lets use TCQ. Lets suppose that we have 4 quantizers:

\begin{verbatim}
-3.5   -2.5   -1.5   -0.5    0.5    1.5    2.5    3.5
--+------+------+------+------+------+------+------+--
  :      :      :      :      :      :      :      :
--+------:------:------:------+------:------:------:-- Q0 (00)
  0      :      :      :      1      :      :      :
---------+------:------:-------------+------:------:-- Q1 (01)
         0      :      :             1      :      :
----------------+------:--------------------+------:-- Q2 (10)
                0      :                    1      :
-----------------------+---------------------------+-- Q4 (11)
                       0                           1                 
\end{verbatim}
 
and that, for example}:

\begin{verbatim}
FSM = [ [0, 2], [0, 2], [1, 3], [3, 1] ] # Finite State Machine
\end{verbatim}

Notice that \verb|FSM[0][0] = 0|, which means that we can use Q0 after
using Q0, encoding a 0, \verb|FSM[0][1] = 2|, which means that we can
use Q2 after using Q0, encoding a 1. Therefore, considering such FSM,
we need only to output one bit to determine the next used quantizer.

Now, lets encode:

\begin{verbatim}
Input     Q0       Q1       Q2         Q3
------+-----------------------------------
  0.2 |  0.3      1.3      1.7        0.7 <- |Quantization errors|, step 0
      |  | \     /   \    /   \      /  |
      | 0|   1\ /      \/      \ /      |
      |  |     /  \   /  \   /  \       | 
      |  |    /     / \  / \     \      |
      |  |   /    /   /  \   \    \     |
  1.6 | 0.3 1.3  1.7 0.7  0.3 1.3  1.7 0.7
      |   +   +    +   +    +   +    +   +
      | 1.1 0.1  0.1 0.1  0.9 0.9  1.9 1.9
      |   =   =    =   =    =   =    =   =
      | 1.4 1.4  1.8 0.8  1.2 2.2  3.6 2.6 <- |Accumulated quantization errors|, step 1 
      |  | \     /   \    /   \      /  |
      |  |    \ /      \/      \ /      |
      |  |     /  \   /  \   /  \       | 
      |  |    /     / \  / \     \      |
      |  |   /    /   /  \   \    \     |
  2.3 | 1.4 0.8  1.2 2.6  1.4 0.8  1.2 2.6 
      |   +   +    +   +    +   +    +   +
      | 1.8 1.8  0.8 0.8  0.2 0.2  1.2 1.2
      |   =   =    =   =    =   =    =   =
      | 3.2 2.6  2.0 3.4  1.6 1.0  2.4 3.8 <- |Accumulated quantization errors|, step 2
\end{verbatim}
%}}}

Therefore, the best combination of quantizers is (in reverse order)
Q2, Q1, Q3, generating the code-word <11><0><1> and a total distortion
of 1.0.

Notice that if the FSM is fully connected (and therefore, the trellis too) the number of output bits will be higher but als

\section{What do I have to do?}
%{{{

\begin{enumerate}
\item Create a notebook named ``bit-rate\_control.ipynb'' that, given
  a maximum bit-rate, finds the quantization step $\Delta^*$ that
  minimizes the distortion. Use the quantizer your prefer.
\end{enumerate}

%}}}

\section{Timming}

Please, finish this milestone before the next class session.

\section{Deliverables}

None.

\section{Resources}

\renewcommand{\addcontentsline}[3]{} % Remove functionality of \addcontentsline
\bibliography{data-compression,signal-processing,DWT,image-processing}
