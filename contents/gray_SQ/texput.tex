% Emacs, this is -*-latex-*-

\input{../../definitions}
\title{\SM{} - Scalar Quantization of Gray-scale Images}

\maketitle
\tableofcontents

\section{Objective}
This task shows how to implement a simple
\href{https://en.wikipedia.org/wiki/Lossy_compression}{lossy}
\href{https://en.wikipedia.org/wiki/Grayscale}{(gray-scale) image}
\href{https://en.wikipedia.org/wiki/Image_compression}{compressor}~\cite{vruiz__image_IO}
based on Scalar
Quantization~\cite{vruiz__scalar_quantization,sayood2017introduction,vetterli2014foundations}
and PNG~\cite{vruiz__PNG}. This compressor basically removes the
number of different gray
\href{https://en.wikipedia.org/w/index.php?title=Tone_(color)&redirect=no}{tones}
in a gray-scale image (normally,
\href{https://en.wikipedia.org/wiki/Visual_system}{humans} hardly
distinguish more than 64 different
\href{https://en.wikipedia.org/wiki/Color}{colors}). Therefore, the
main objective of this task is to analyze the impact in the encoding
performance (in terms of a RD (Rate/Distortion)
curve~\cite{vruiz__information_theory}) when this kind of visual
redundancy (the limited number of recognizeable gray tone levels) is
exploited.

%\section{Scalar quantization applied to the ``intensity'' domain of a gray-scale image}
%\section{Minimizing the rate/visual-distortion tradeoff}
%\section{Rate/(visual-distortion) optimized scalar quantization in gray-scale images}
\section{Uniform quantization of gray-scale pixel intensities}
Uniform Quantization (UQ) transform each input signal value
$\mathbf{s}_i$ in a quantization index $\mathbf{k}_i$, without
considering the rest of samples, and in general, without any other
information about $\mathbf{s}$~\cite{vruiz__scalar_quantization}.

There are different mapping procedures to convert $\mathbf{s}$ to $\mathbf{k}$, using UQ. The notetooks
\href{https://github.com/Sistemas-Multimedia/Sistemas-Multimedia.github.io/blob/master/contents/gray_SQ/gray_SQ_deadzone.ipynb}{gray\_SQ\_deadzone.ipynb},
\href{https://github.com/Sistemas-Multimedia/Sistemas-Multimedia.github.io/blob/master/contents/gray_SQ/gray_SQ_midrise.ipynb}{gray\_SQ\_midrise.ipynb},
\href{https://github.com/Sistemas-Multimedia/Sistemas-Multimedia.github.io/blob/master/contents/gray_SQ/gray_SQ_midtread.ipynb}{gray\_SQ\_midtread.ipynb})
shows the RD performance of different scalar quantizers. As you can
see, the way in which the visual information is quantized has an
influence in the RD performance. Also, as it can be checked in the
notebooks, in general, the better quantizer is the Lloyd-Max quantizer
because it adapts the QSSs (Quantization Step Sizes) to the
\href{https://en.wikipedia.org/wiki/Probability_density_function}{PDF
  (Probability Density Function)} of the image. However, notice also
that, since the QSS depends on the image, they must be ``transmitted''
to the decoder, which decreases the definitive RD performance.

\section{Non UQ of gray-scale pixel intensities}
,
\href{https://github.com/Sistemas-Multimedia/Sistemas-Multimedia.github.io/blob/master/contents/gray_SQ/gray_SQ_companded.ipynb}{gray\_SQ\_companded.ipynb},
\href{https://github.com/Sistemas-Multimedia/Sistemas-Multimedia.github.io/blob/master/contents/gray_SQ/gray_SQ_LloydMax.ipynb}{gray\_SQ\_LloydMax.ipynb}


\section{Comparison}

and
\href{https://github.com/Sistemas-Multimedia/Sistemas-Multimedia.github.io/blob/master/contents/gray_SQ/compare_quantizers.ipynb}{compare\_quantizers.ipynb}


Notice also the remarkable perormance of the DeadZone Quantizer (DZQ)
at low bit-rates. This is one of the reasons why the DZQ is used in
several standard image and video codecs (such as JPEG 2000 and
H.264). Another reason is that, when the QSSs are powers of two, we
can use an
\href{https://en.wikipedia.org/wiki/Bit_plane}{bit-plane}-based
entropy encoder.

Finally, notice that (you must see the notebooks) when the QSSs are
powers of 2, the points of the RD curve tend to belong to the convex
hull. On the contrary, if the QSSs can be any, the RD curves can have
points for bit-rates $i$ and $i+1$ where the condition
$\lambda_i\ge\lambda_{i+1}$ (being $\lambda_i$ the slope of the RD
curve at the bit-rate $i$) is not satisfied, which can difficult the
(bit-)rate control.

\section{Rate/distortion optimized scalar quantization in gray-scale images}
The RD performance of the previous encoding algorithm (first quantize
the pixels, then entropy encode the quantization indexes) depends on
how many bits\footnote{That can be a fractional number of bits.} each
quantized pixel (throughout a quantization index) contributes to the
code-stream.

The objective of 

\section{What do I have to do?}
\begin{enumerate}
\item \textbf{Implement a rate control:} Extend (modify) one of the
  previous notebooks to incorporate a rate control procedure. Such
  algorithm should be able to find, given a maximum bit-rate
  $R^\text{max}$, the quantization step (size) $\Delta^*$ that
  minimizes the distortion (in terms of the
  \href{https://en.wikipedia.org/wiki/Root-mean-square_deviation}{RMSE
    (Root Mean Square Error)}, see the notebooks).
\end{enumerate}

\section{Timming}
Please, finish this milestone before the day of the ``exam''.

\section{Deliverables}
The modified notebook.

\section{Resources}
\renewcommand{\addcontentsline}[3]{} % Remove functionality of \addcontentsline
\bibliography{data-compression,signal-processing,DWT,image-processing,quantization,information_theory,image-formats}

%%%%%%%%%%%

\begin{comment}
\section{Distortion control}
We do not provide any accurate distortion control algorithm. Our
compressor is able to control the number of gray tones in the
reconstructed image, using a deadzone scalar quantizer. The
quantization steps are selected simulating a
\href{https://en.wikipedia.org/wiki/Bit_plane}{bit-plane}
encoding. Therefore, for 8-bit images, the quantization steps are
$\Delta\in\{128, 64, 32, 16, 8, 4, 2, 1\}$ (powers of $2$). Notice
that we cannot control the distortion in terms of the RMSE, for
example.

\section{Rate control}
The bit-rate (the number of bits/pixel) obtained after using
scalar quantization quantization and PNG depends on:
\begin{enumerate}
\item The number of output indexes generated by the quantizer.
\item The capability of PNG for removing spatial/statistical
  redudancy, aspect that we cannot control with accuracy (only some
  levels of compression are usually available).
\item In the case of SQ, the quantization step size $\Delta$
  used. Notice that, usually, the higher the $\Delta$, the higher the
  compression ratio, the lower the number of bits/pixel, and the lower
  the quality of the reconstructed image.
\end{enumerate}

Therefore, variying $\Delta$ we should be able to generate a Rate/Distortion (RD)
curve~\cite{vruiz__information_theory}, where the $x$-axis represents the bit-rate (in bit/pixel, for
example) and the $y$-axis represents the distortion (the
\href{https://en.wikipedia.org/wiki/Root-mean-square_deviation}{Root
  Mean Square Error (RMSE)}, for example). However, notice that only seven RD points will be available\footnote{This is a direct consequence of using bit-plane encoding.}, and the rate of each point is not controllable.\footnote{Because we cannot control the bit-rate with PNG.}
\end{comment}
