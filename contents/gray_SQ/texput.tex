% Emacs, this is -*-latex-*-

\input{../../definitions}
\title{\SM{} - Scalar Quantization of Gray-scale Images}

\maketitle
\tableofcontents

\section{Objective}
This task shows how to implement a simple
\href{https://en.wikipedia.org/wiki/Lossy_compression}{lossy}
\href{https://en.wikipedia.org/wiki/Grayscale}{(gray-scale) image}
\href{https://en.wikipedia.org/wiki/Image_compression}{compressor}~\cite{vruiz__image_IO}
based on Scalar
Quantization~\cite{vruiz__scalar_quantization,sayood2017introduction,vetterli2014foundations}
and PNG~\cite{vruiz__PNG}. The proposed compressor (the PNG-encoding
of the scalar quantization of an gray image) basically removes the number
of different gray
\href{https://en.wikipedia.org/w/index.php?title=Tone_(color)&redirect=no}{tones}
in a gray-scale image (normally,
\href{https://en.wikipedia.org/wiki/Visual_system}{humans} hardly
distinguish more than 64 different
\href{https://en.wikipedia.org/wiki/Color}{colors}). Therefore, the
main objective of this task is to analyze the impact in the encoding
performance (in terms of a RD (Rate/Distortion)
curve~\cite{vruiz__information_theory}) when this kind of visual
redundancy (the limited number of recognizeable gray tone levels) is
exploited.

%\section{Scalar quantization applied to the ``intensity'' domain of a gray-scale image}
%\section{Minimizing the rate/visual-distortion tradeoff}
%\section{Rate/(visual-distortion) optimized scalar quantization in gray-scale images}
\section{Uniform scalar quantization of gray-scale pixel intensities}
Uniform Scalar Quantization (USQ) transform each input signal value
$\mathbf{s}_i$ in a quantization index $\mathbf{k}_i$, without
considering the rest of samples, and in general, without any other
information about $\mathbf{s}$~\cite{vruiz__scalar_quantization}.

There are different mapping procedures to convert $\mathbf{s}$ into
$\mathbf{k}$, using USQ (the notetooks
\href{https://github.com/Sistemas-Multimedia/Sistemas-Multimedia.github.io/blob/master/contents/gray_SQ/gray_SQ_deadzone.ipynb}{gray\_SQ\_deadzone.ipynb},
\href{https://github.com/Sistemas-Multimedia/Sistemas-Multimedia.github.io/blob/master/contents/gray_SQ/gray_SQ_midrise.ipynb}{gray\_SQ\_midrise.ipynb},
\href{https://github.com/Sistemas-Multimedia/Sistemas-Multimedia.github.io/blob/master/contents/gray_SQ/gray_SQ_midtread.ipynb}{gray\_SQ\_midtread.ipynb})
shows the RD performance of different USQs). As you can see, the way
in which the visual information is quantized has an influence in the
RD performance.

\section{Non-Uniform SQ of gray-scale pixel intensities}
Uniform quantizers are efficient (minimize the distortion) only if the
input samples (gray-scale values of the pixels) are uniformly
distributed among the quantization
bins~\cite{vruiz__scalar_quantization}. However, when the probability
of the samples is not ``flat'' (or the number of bins is very small
compared to the possible number of input values), we can use better
quantizers. For example, if we know that most of the samples are small
integer values (positive and negative), a quantizer such as
\href{https://github.com/Sistemas-Multimedia/Sistemas-Multimedia.github.io/blob/master/contents/gray_SQ/gray_SQ_companded.ipynb}{gray\_SQ\_companded.ipynb}
can be more suitable than an uniform one. In general, when the samples
follow a probability distribution that only can be modeled using the
\href{https://en.wikipedia.org/wiki/Probability_density_function}{PDF
  (Probability Density Function)} of the image, then an efficient USQ
is
\href{https://github.com/Sistemas-Multimedia/Sistemas-Multimedia.github.io/blob/master/contents/gray_SQ/gray_SQ_LloydMax.ipynb}{gray\_SQ\_LloydMax.ipynb}.

\section{Comparison}

As it can be checked in \href{https://github.com/Sistemas-Multimedia/Sistemas-Multimedia.github.io/blob/master/contents/gray_SQ/compare_quantizers.ipynb}{compare\_quantizers.ipynb}, in general, the better
quantizer is the Lloyd-Max quantizer because it adapts the QSSs
(Quantization Step Sizes) to the
\href{https://en.wikipedia.org/wiki/Probability_density_function}{PDF
  (Probability Density Function)} of the image. However, notice also
that, since the QSSs depend on the PDF of the image, the PDF or the
correspondence between the quantization indexes and the corresponding
representation levels (the ``pallete'') must be also ``transmitted''
to the decoder, which decreases the final RD performance.

Notice also the remarkable perormance of the DeadZone Quantizer (DZQ)
at low bit-rates. This is one of the reasons why the DZQ is used in
several standard image and video codecs (such as JPEG 2000 and
H.264). Another reason is that, when the QSSs are powers of two, we
can use an
\href{https://en.wikipedia.org/wiki/Bit_plane}{bit-plane}-based
entropy encoder.

Finally, notice that (you must see the notebooks) when the QSSs are
powers of 2, the points of the RD curve tend to belong to the convex
hull of the RD curve. On the contrary, if the QSSs can be any, the RD
curves can have points for bit-rates $i$ and $i+1$ where the condition
$\lambda_i\ge\lambda_{i+1}$ (being $\lambda_i$ the slope of the RD
curve at the bit-rate $i$) is not satisfied, which can difficult the
(bit-)rate control.

\section{RD optimized quantizer design}
So far, we have designed the image compressor in two steps: (1)
quantize the pixels trying to minimize the distortion, and (2) entropy
code (compress) the quantization indexes. However, if we assume that
the entropy encoding performance is proportional to some
rate-prediction metric, such as the entropy, it is possible to design
the quantizer minizing the two RD variables (rate and distortion) at
the same time~\cite{sayood2017introduction}. However, there is not
(yet) any known reason to think that is approach will be generate
better RD curves that the one in both parameters (R and D) are
minimized independently. Besides, the joint optimization of R and D
makes the quantizer dependent of the entropy codec, that reduces the
flexility of the encoding system.

\section{What do I have to do?}
\begin{enumerate}
\item \textbf{Implement a rate control:} Extend (modify) one of the
  previous notebooks to incorporate a rate control procedure. Such
  algorithm should be able to find, given a maximum bit-rate
  $R^\text{max}$, the QSS $\Delta^*$ that minimizes the distortion (in
  terms of the
  \href{https://en.wikipedia.org/wiki/Root-mean-square_deviation}{RMSE
    (Root Mean Square Error)}, see the notebooks).
\end{enumerate}

\section{Timming}
Please, finish this milestone before the day of the ``exam''.

\section{Deliverables}
The modified notebook.

\section{Resources}
\renewcommand{\addcontentsline}[3]{} % Remove functionality of \addcontentsline
\bibliography{data-compression,signal-processing,DWT,image-processing,quantization,information_theory,image-formats}

%%%%%%%%%%%

\begin{comment}
\section{Distortion control}
We do not provide any accurate distortion control algorithm. Our
compressor is able to control the number of gray tones in the
reconstructed image, using a deadzone scalar quantizer. The
quantization steps are selected simulating a
\href{https://en.wikipedia.org/wiki/Bit_plane}{bit-plane}
encoding. Therefore, for 8-bit images, the quantization steps are
$\Delta\in\{128, 64, 32, 16, 8, 4, 2, 1\}$ (powers of $2$). Notice
that we cannot control the distortion in terms of the RMSE, for
example.

\section{Rate control}
The bit-rate (the number of bits/pixel) obtained after using
scalar quantization quantization and PNG depends on:
\begin{enumerate}
\item The number of output indexes generated by the quantizer.
\item The capability of PNG for removing spatial/statistical
  redudancy, aspect that we cannot control with accuracy (only some
  levels of compression are usually available).
\item In the case of SQ, the quantization step size $\Delta$
  used. Notice that, usually, the higher the $\Delta$, the higher the
  compression ratio, the lower the number of bits/pixel, and the lower
  the quality of the reconstructed image.
\end{enumerate}

Therefore, variying $\Delta$ we should be able to generate a Rate/Distortion (RD)
curve~\cite{vruiz__information_theory}, where the $x$-axis represents the bit-rate (in bit/pixel, for
example) and the $y$-axis represents the distortion (the
\href{https://en.wikipedia.org/wiki/Root-mean-square_deviation}{Root
  Mean Square Error (RMSE)}, for example). However, notice that only seven RD points will be available\footnote{This is a direct consequence of using bit-plane encoding.}, and the rate of each point is not controllable.\footnote{Because we cannot control the bit-rate with PNG.}
\end{comment}
